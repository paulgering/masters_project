---
title: "**Analyses for individual differences study**"
output:
  html_document: default
---

## Loading packages

```{r loadlib, echo = TRUE, results = 'hide', warning = FALSE, message = FALSE}
#renv - Store packages and keep account of package versions
if (!require('renv')) 
{
  install.packages('renv');
}
library(renv) 
renv::restore()

# Load packages
library(AER) #conduct an overdispersion test on Poisson Models
library(dplyr) #Preparing the data for analysis
library(here) #locate files based on current working directory
library(MASS) #Fit negative binomial regression
library(MuMIn) #Calculate the Akaike Information Criterion (AIC) for each model
library(WebPower) #Conduct power analysis
```

## Load the data 
Loading the data from the current working directory.

## Testing the code
```{r}
num_rows <- 125

condition <- sample(0:1, num_rows, replace = TRUE)
age_at_survey <- sample(503:614, num_rows, replace = TRUE)
twe_length <- sample(240:300, num_rows, replace = TRUE)
twe_pca_count <- sample(0:25, num_rows, replace = TRUE)
twe_sc_pca_only_count <- sample(0:25, num_rows, replace = TRUE)
twe_cl_pca_only_count <- sample(0:25, num_rows, replace = TRUE)
twe_responses_pca_only_count <- sample(0:25, num_rows, replace = TRUE)
twe_sc_all_count <- sample(0:25, num_rows, replace = TRUE)
twe_cl_all_count <- sample(0:25, num_rows, replace = TRUE)
twe_responses_all_count <- sample(0:25, num_rows, replace = TRUE)
sev_cdi_vocab_count <- sample(0:300, num_rows, replace = TRUE)

# Create a data frame with the generated columns
df <- data.frame(age_at_survey, condition, twe_length, twe_pca_count, twe_sc_pca_only_count, twe_cl_pca_only_count, twe_responses_pca_only_count, twe_sc_all_count, twe_cl_all_count, twe_responses_all_count, sev_cdi_vocab_count)

```

## Prospective Power Analysis

As the baselinerate, the median of infant vocab count will be used to ensure that we have an accurate calculation of the sample size that would have been needed to detect a small/medium effect size. 

```{r}
baselinerate = median(df$sev_cdi_vocab_count) #Baseline rate of infant vocab size

#Small effect size

d=0.2

lo=d*(pi/sqrt(3)) 

increase = exp(lo)

slope=(baselinerate+increase)/baselinerate #Calculating the expected slope based on an effect size of 0.2

wp.poisson(n = NULL, exp0 = baselinerate, exp1 = slope, alpha = 0.05, power = 0.8, family = "Bernoulli", alternative="greater")

#Medium effect size

d=0.5

lo=d*(pi/sqrt(3)) 

increase = exp(lo)

slope=(baselinerate+increase)/baselinerate # Calculating the expected slope based on an effect size of 0.5

wp.poisson(n = NULL, exp0 = baselinerate, exp1 = slope, alpha = 0.05, power = 0.8, family = "Bernoulli", alternative="greater")

```

## Preparing the researcher-coded behaviours 

The below code is used to prepare the counts of researcher-coded behaviours prior to incorporating them into Poisson regression models. The code takes the columns that begin with 12 months, which happens to be the columns containing the counts of researcher-coded behaviours (aside from 12m_length), and mutates them using the following steps: 
1. Adding one to the counts to avoid zero counts 
2. Prorating the counts by Dividing them by the length of the videos at 12 months and multiplying them by 300 (the maximum length of a video)
3. Log transforming the counts to reduce skewness
4. Robust scaling by subtracting the median from each of the values and dividing by the interquartile range of each column 

```{r}
# Proscaling and log transforming the counts
df1 <- df %>%
  mutate(across(
    starts_with("twe_") & !matches("twe_length"),
    ~ (log(((. + 1) / twe_length) * 300))
  ))

# robust scaling to be done with the log transformed variables 
df2 <- df1 %>% 
  mutate(across(
    starts_with("twe_") & !matches('twe_length'),
    ~ ((. - median(.)) / IQR(.))
  ))

```

## Centering the control variables condition around 0

```{r}
# Centering condition around 0
df2$condition <- df2$condition - 0.5

# Centering age around the mean 
df2$centered_age <- scale(df2$age_at_survey, center = TRUE, scale = FALSE)
```

## Fitting the models to a Poisson Distribution
Building the models using poisson regressions. 

### Model 0 - Null Model 

```{r}
M0 = glm(sev_cdi_vocab_count ~ condition + centered_age, family = poisson, data=df2)
```

### Model 1 - Count of infant 'intentional' Prelinguistic Communicative Acts

```{r}
M1 = glm(sev_cdi_vocab_count ~ condition + centered_age + twe_pca_count ,family=poisson,data=df2)

summary(M1)
```

### Model 2 - Count of infant 'intentional' Prelinguistic Communicative Acts that elicited a response of any kind

```{r}
M2 = glm(sev_cdi_vocab_count ~ condition + centered_age + twe_responses_pca_only_count ,family=poisson,data=df2)

summary(M2)
```

### Model 3 - Count of infant 'intentional Prelinguistic Communicative Acts that elicited a content-light response

```{r}
M3 = glm(sev_cdi_vocab_count ~ condition + centered_age + twe_cl_pca_only_count ,family=poisson,data=df2)

summary(M3)
```

### Model 4 - Count of infant 'intentional Prelinguistic Communicative Acts that elicited a semantically contingent response

```{r}
M4 = glm(sev_cdi_vocab_count ~ condition + centered_age + twe_sc_pca_only_count ,family=poisson,data=df2)


summary(M4)
```

### Model 5 - A count of (infant 'intentional Prelinguistic Communicative Acts + non-gaze-coordinated vocalisations) that elicited a response of any kind

```{r}
M5 = glm(sev_cdi_vocab_count ~ condition + centered_age + twe_responses_all_count ,family=poisson,data=df2)

summary(M5)
```

### Model 6 - A count of (infant 'intentional Prelinguistic Communicative Acts + non-gaze-coordinated vocalisations) that elicited a content-light response

```{r}
M6 = glm(sev_cdi_vocab_count ~ condition + centered_age + twe_cl_all_count ,family=poisson,data=df2)

summary(M6)
```

### Model 7 - A count of (infant 'intentional Prelinguistic Communicative Acts + non-gaze-coordinated vocalisations) that elicited a semantically contingent response

```{r}
M7 = glm(sev_cdi_vocab_count ~ condition + centered_age + twe_sc_all_count ,family=poisson,data=df2)

summary(M7)
```

## Testing for overdispersion
Determine whether overdispersion has occurred for any of the built models using the dispersiontest function.

```{r}
# Testing for overdispersion in each of the models
dispersiontest(M1)
dispersiontest(M2)
dispersiontest(M3)
dispersiontest(M4)
dispersiontest(M5)
dispersiontest(M6)
dispersiontest(M7)
```

## Negative binomial analyses 
If any of the dispersion tests has p < 0.05, a negative binomial regression will be fitted instead and this should be reported instead.

```{r}
M0_nb = glm.nb(sev_cdi_vocab_count ~ condition + centered_age,data=df2)

summary(M0_nb)
```

```{r}
M1_nb = glm.nb(sev_cdi_vocab_count ~ condition + centered_age + twe_pca_count,data=df2)

summary(M1_nb)
```

```{r}
M2_nb = glm.nb(sev_cdi_vocab_count ~ condition + centered_age + twe_responses_pca_only_count,data=df2)

summary(M2_nb)
```

```{r}
M3_nb = glm.nb(sev_cdi_vocab_count ~ condition + centered_age + twe_cl_pca_only_count,data=df2)

summary(M3_nb)
```

```{r}
M4_nb = glm.nb(sev_cdi_vocab_count ~ condition + centered_age + twe_sc_pca_only_count,data=df2)


summary(M4_nb)
```

```{r}
M5_nb = glm.nb(sev_cdi_vocab_count ~ condition + centered_age + twe_responses_all_count,data=df2)

summary(M5_nb)
```

```{r}
M6_nb = glm.nb(sev_cdi_vocab_count ~ condition + centered_age + twe_cl_all_count,data=df2)

summary(M6_nb)
```

```{r}
M7_nb = glm.nb(sev_cdi_vocab_count ~ condition + centered_age + twe_sc_all_count,data=df2)

summary(M7_nb)
```

## Testing Prediction 1: Infants who produce more PCA's will have a alrger vocabulary size at 18 months 

```{r}
anova(M1, M0)
```

If the tests detect overdispersion for any of the models, the models built using a negative binomial regression will be included in this code instead of the models built using a Poisson Regression. 

If overdispersion is detected for model 1 and the null model: 

```{r}
anova(M1_nb, M0_nb)
```

## Comparing the AIC of the models to test predictions 2, 3, and 4 and to answer two questions in an exploratory analysis:

```{r}
model.sel(M1, M2, M3, M4, M5, M6, M7)
```

Alternative code in case overdispersion is detected in all of the models: 

```{r}
model.sel(M1_nb, M2_nb, M3_nb, M4_nb, M5_nb, M6_nb, M7_nb)
```
